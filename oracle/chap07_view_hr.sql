-- 뷰 (VIEW)
select * from emp_details_view;

-- 뷰 확인
select * from user_views;

SELECT
  e.employee_id,
  e.job_id,
  e.manager_id,
  e.department_id,
  d.location_id,
  l.country_id,
  e.first_name,
  e.last_name,
  e.salary,
  e.commission_pct,
  d.department_name,
  j.job_title,
  l.city,
  l.state_province,
  c.country_name,
  r.region_name
FROM
  employees e,
  departments d,
  jobs j,
  locations l,
  countries c,
  regions r
WHERE e.department_id = d.department_id
  AND d.location_id = l.location_id
  AND l.country_id = c.country_id
  AND c.region_id = r.region_id
  AND j.job_id = e.job_id;
  
select * from emp_details_view;

-- 뷰 생성
--CREATE [OR REPLACE] [FORECE | NOFORCE] VIEW 뷰이름
--[(컬럼별칭1, 컬럼별칭2, ....)]
--AS 저장할쿼리문
--[WITH CHECK OPTION]
--[WITH READ ONLY]

CREATE OR REPLACE VIEW VIEW_EMP30
AS
SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID = 30;

-- OR REPLACE 옵션이 없으면 기존에 같은 이름의 뷰가 존재하면 생성 불가
CREATE VIEW VIEW_EMP30
AS
SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID = 30; -- ORA-00955: name is already used by an existing object

CREATE OR REPLACE VIEW VIEW_EMP30
AS
SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID = 30;

SELECT * FROM VIEW_EMP30;

-- EMPLOYEES 복사
CREATE TABLE EMP
AS (SELECT * FROM EMPLOYEES);

SELECT * FROM EMP;

--"LAST_NAME", "EMAIL", "HIRE_DATE", "JOB_ID" IS NOT NULL
DROP VIEW VIEW_EMP30;

CREATE OR REPLACE VIEW VIEW_EMP30
AS
SELECT * FROM EMP WHERE DEPARTMENT_ID = 30;

SELECT * FROM VIEW_EMP30;
SELECT * FROM EMP;

INSERT INTO VIEW_EMP30 VALUES(300, '길동', '홍', 'HONG', '010.123.4567', SYSDATE, 'PU_CLERK', 3000, NULL, 114, 30);

-- 뷰로 조회되지 않지만, EMP에 저장성공
INSERT INTO VIEW_EMP30 VALUES(301, '길동', '홍', 'HONG', '010.123.4567', SYSDATE, 'PU_CLERK', 3000, NULL, 114, 60);

UPDATE VIEW_EMP30 SET PHONE_NUMBER = '010.999.9999' WHERE EMPLOYEE_ID = 300; -- 성공
UPDATE VIEW_EMP30 SET FIRST_NAME = '길서' WHERE EMPLOYEE_ID = 301; -- 실패

DELETE FROM VIEW_EMP30 WHERE EMPLOYEE_ID = 300; -- 성공
DELETE FROM VIEW_EMP30 WHERE EMPLOYEE_ID = 301; -- 실패

-- WITH READ ONLY : 해당 뷰를 통해서는 조회만 가능하고 DML문은 불가능
CREATE OR REPLACE VIEW VIEW_EMP90
AS SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, JOB_ID, HIRE_DATE, DEPARTMENT_ID 
FROM EMP
WHERE DEPARTMENT_ID = 90
WITH READ ONLY;

SELECT * FROM VIEW_EMP90;
SELECT * FROM EMP;

-- 아래 세 문장은 SQL 오류: ORA-42399: cannot perform a DML operation on a read-only view
-- INSERT INTO VIEW_EMP90 VALUES(303, '대호', '이', 'LEE', 'AD_VP', SYSDATE, 90);
-- UPDATE VIEW_EMP90 SET HIRE_DATE = SYSDATE WHERE EMPLOYEE_ID = 102;
-- DELETE VIEW_EMP90 WHERE EMPLOYEE_ID = 102;

-- [WITH CHECK OPTION]
-- 지정한 조건을 만족하는 데이터에 한해 DML문이 가능
CREATE OR REPLACE VIEW VIEW_EMP100
AS SELECT EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID, DEPARTMENT_ID FROM EMP WHERE DEPARTMENT_ID = 100;

SELECT * FROM VIEW_EMP100;
SELECT * FROM EMP WHERE DEPARTMENT_ID = 30;

INSERT INTO VIEW_EMP100 VALUES(400, 'Choi', 'COI', SYSDATE, 'FI_ACCOUNT', 100);
INSERT INTO VIEW_EMP100 VALUES(401, 'Park', 'PARK', SYSDATE, 'FI_ACCOUNT', 30);

--UPDATE VIEW_EMP100 SET SALARY = 20000 WHERE DEPARTMENT_ID = 30; -- SQL 오류: ORA-00904: "SALARY": invalid identifier
--SELECT SALARY FROM VIEW_EMP100; -- ORA-00904: "SALARY": invalid identifier

DELETE FROM VIEW_EMP100 WHERE EMPLOYEE_ID = 400; -- 삭제 성공
DELETE FROM VIEW_EMP100 WHERE EMPLOYEE_ID = 401; -- 삭제 실패

-----------------------------------------------------------

CREATE OR REPLACE VIEW VIEW_EMP100_CK
AS SELECT EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID, DEPARTMENT_ID 
FROM EMP WHERE DEPARTMENT_ID = 100
WITH CHECK OPTION;

SELECT * FROM VIEW_EMP100_CK;
INSERT INTO VIEW_EMP100_CK VALUES(500, 'Choi', 'COI', SYSDATE, 'FI_ACCOUNT', 100);

--INSERT INTO VIEW_EMP100_CK VALUES(501, 'Park', 'PARK', SYSDATE, 'FI_ACCOUNT', 30); -- SQL 오류: ORA-01402: view WITH CHECK OPTION where-clause violation
UPDATE VIEW_EMP100_CK SET HIRE_DATE = SYSDATE WHERE EMPLOYEE_ID = 400;
UPDATE VIEW_EMP100_CK SET HIRE_DATE = '02/12/02' WHERE EMPLOYEE_ID = 401; -- 업데이트 실패

DELETE FROM VIEW_EMP100_CK WHERE EMPLOYEE_ID = 500;
DELETE FROM VIEW_EMP100_CK WHERE EMPLOYEE_ID = 401; -- 삭제 실패 (0개 행)

-- ==========================================================
-- [FORCE]
DROP TABLE MEMBER;
DROP TABLE BOARD;

-- MEMBER테이블이 존재하지 않을 때, FORCE 옵션으로 뷰 생성
-- "경고: 컴파일 오류와 함께 뷰가 생성되었습니다." 문구와 함께 뷰는 생성이 된다.
CREATE OR REPLACE FORCE VIEW VIEW_MEMBER
AS SELECT * FROM MEMBER;

CREATE TABLE MEMBER(
    USERID VARCHAR2(12),
    PASSWD VARCHAR2(15)
);

INSERT INTO MEMBER VALUES('HONG', '1234');
SELECT * FROM MEMBER;
SELECT * FROM VIEW_MEMBER;

-- 만약 뷰에 컬럼별칭을 붙여 생성한다면
-- 해당 뷰에 대해서는 컬럼별칭으로만 조건절을 만들어야 한다.

CREATE OR REPLACE VIEW VIEW_EMP(사번, 이름, 급여, 부서번호)
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID FROM EMP;

SELECT * FROM VIEW_EMP;

--SELECT * FROM VIEW_EMP WHERE DEPARTMENT_ID = 90; -- ORA-00904: "DEPARTMENT_ID": invalid identifier
SELECT * FROM VIEW_EMP WHERE 부서번호 = 90;

--==================================================================

-- 그룹 함수를 이용하여 뷰를 생성할 때에는
-- 반드시 그룹함수를 지정한 컬럼에 컬럼별칭을 주어야 한다.
-- DATA MANIPULATION 불가

-- 부서별로 급여총액, 급여평균으로 뷰 생성
SELECT DEPARTMENT_ID, SUM(SALARY), AVG(SALARY) FROM EMP
GROUP BY DEPARTMENT_ID;

--CREATE OR REPLACE VIEW VIEW_SAL
--AS
--SELECT DEPARTMENT_ID, SUM(SALARY), AVG(SALARY) FROM EMP
--GROUP BY DEPARTMENT_ID; -- ORA-00998: must name this expression with a column alias

CREATE OR REPLACE VIEW VIEW_SAL
AS
SELECT DEPARTMENT_ID, SUM(SALARY) 급여총액, AVG(SALARY) 급여평균 FROM EMP
GROUP BY DEPARTMENT_ID;

CREATE OR REPLACE VIEW VIEW_SAL(부서번호, 급여총액, 급여평균)
AS
SELECT DEPARTMENT_ID, SUM(SALARY) , AVG(SALARY) FROM EMP
GROUP BY DEPARTMENT_ID; --> 별칭 붙이는 방식은 두개 다 가능

SELECT * FROM VIEW_SAL; 

UPDATE VIEW_SAL SET 급여총액 = 20000 WHERE DEPARTMENT_ID = 30; -- SQL 오류: ORA-01732: data manipulation operation not legal on this view

--=======================================================
-- 조인으로 뷰를 생성한 경우
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

CREATE OR REPLACE VIEW VIEW_EMP_DEPT
AS 
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

SELECT * FROM VIEW_EMP_DEPT WHERE EMPLOYEE_ID = 200;

INSERT INTO VIEW_EMP_DEPT VALUES(300, 'HONG', 30, 'Purchasing'); -- SQL 오류: ORA-01776: cannot modify more than one base table through a join view
UPDATE VIEW_EMP_DEPT SET FIRST_NAME = 'GILDONG' WHERE EMPLOYEE_ID = 200; -- 가능
DELETE FROM VIEW_EMP_DEPT WHERE EMPLOYEE_ID = 200;

INSERT INTO EMPLOYEES VALUES(300, '길동', '홍', 'HONG', '010.123.4567', SYSDATE, 'PU_CLERK', 3000, NULL, 114, 30);
SELECT * FROM VIEW_EMP_DEPT;
UPDATE VIEW_EMP_DEPT SET FIRST_NAME = '길순' WHERE EMPLOYEE_ID = 300;
DELETE FROM VIEW_EMP_DEPT WHERE EMPLOYEE_ID = 300;

--UPDATE VIEW_EMP_DEPT SET DEPARTMENT_NAME = 'Marketing' WHERE EMPLOYEE_ID = 200;
ROLLBACK;
-- ============================================================================
-- Top-N
-- 급여가 높은 순으로 5명만 출력하려고 한다.
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
ORDER BY SALARY DESC;

-- ROWNUM 
CREATE TABLE TEST(
    USERID NUMBER(3) PRIMARY KEY,
    USERNAME VARCHAR2(15)
);

INSERT INTO TEST VALUES(1, 'USER1');
INSERT INTO TEST VALUES(2, 'USER2');
INSERT INTO TEST VALUES(3, 'USER3');
INSERT INTO TEST VALUES(4, 'USER4');
INSERT INTO TEST VALUES(5, 'USER5');
INSERT INTO TEST VALUES(10, 'USER10');
INSERT INTO TEST VALUES(6, 'USER6');
INSERT INTO TEST VALUES(7, 'USER7');
INSERT INTO TEST VALUES(8, 'USER8');
INSERT INTO TEST VALUES(9, 'USER9');

SELECT * FROM TEST;
SELECT ROWNUM, TEST.* FROM TEST;
SELECT ROWNUM, TEST.* FROM TEST WHERE ROWNUM BETWEEN 1 AND 5;
SELECT ROWNUM, TEST.* FROM TEST WHERE ROWNUM = 1;
SELECT ROWNUM, TEST.* FROM TEST WHERE ROWNUM >= 1;
SELECT ROWNUM, TEST.* FROM TEST WHERE ROWNUM >= 2;
SELECT ROWNUM, TEST.* FROM TEST WHERE ROWNUM BETWEEN 6 AND 10;

SELECT  * FROM (SELECT ROWNUM, TEST.* FROM TEST)
WHERE ROWNUM BETWEEN 1 AND 5;

SELECT * FROM (SELECT ROWNUM RN, TEST.* FROM TEST)
WHERE RN BETWEEN 6 AND 10;

-- 급여가 높은 순으로 5명만 출력하려고 한다.
-- 1) 급여 내림차순 정렬
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
ORDER BY SALARY DESC;

-- 2) 1)번 쿼리문에서 ROWNUM 컬럼을 활용 출력
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, SALARY FROM EMPLOYEES
ORDER BY SALARY DESC;

-- 3) 2번 쿼리문을 뷰 생성 (ROWNUM 제외하고)
CREATE OR REPLACE VIEW VIEW_SAL_TOP5
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY FROM EMPLOYEES
ORDER BY SALARY DESC;

SELECT * FROM VIEW_SAL_TOP5;

SELECT ROWNUM, S.* FROM VIEW_SAL_TOP5 S
WHERE ROWNUM < 6;

-- 1) 입사일이 늦은 7명을 출력해보세요.
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES
ORDER BY HIRE_DATE DESC;

CREATE OR REPLACE VIEW VIEW_HD_TOP7
AS
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES
ORDER BY HIRE_DATE DESC;

SELECT ROWNUM, H.* FROM VIEW_HD_TOP7 H
WHERE ROWNUM < 8;

-- 2) 1)번의 7명 이후에 입사한 7명을 출력해 보세요.

SELECT * FROM (SELECT ROWNUM RN, H.* FROM VIEW_HD_TOP7 H)
WHERE RN BETWEEN 8 AND 14;